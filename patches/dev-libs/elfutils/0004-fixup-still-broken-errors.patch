diff -Nuar elfutils-0.166.orig/lib/xmalloc.c elfutils-0.166/lib/xmalloc.c
--- elfutils-0.166.orig/lib/xmalloc.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/lib/xmalloc.c	2016-07-09 13:59:54.842923596 +0100
@@ -50,7 +50,7 @@
 
   p = malloc (n);
   if (p == NULL)
-    error (EXIT_FAILURE, 0, _("memory exhausted"));
+    err (EXIT_FAILURE, _("memory exhausted"));
   return p;
 }
 
@@ -63,7 +63,7 @@
 
   p = calloc (n, s);
   if (p == NULL)
-    error (EXIT_FAILURE, 0, _("memory exhausted"));
+    err (EXIT_FAILURE, _("memory exhausted"));
   return p;
 }
 
@@ -75,6 +75,6 @@
 {
   p = realloc (p, n);
   if (p == NULL)
-    error (EXIT_FAILURE, 0, _("memory exhausted"));
+    err (EXIT_FAILURE, _("memory exhausted"));
   return p;
 }
diff -Nuar elfutils-0.166.orig/libcpu/i386_gendis.c elfutils-0.166/libcpu/i386_gendis.c
--- elfutils-0.166.orig/libcpu/i386_gendis.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libcpu/i386_gendis.c	2016-07-09 13:59:54.843923603 +0100
@@ -51,9 +51,12 @@
 main (int argc, char *argv[argc])
 {
   outfile = stdout;
+  int count = 0;
 
-  if (argc == 1)
-    error (EXIT_FAILURE, 0, "usage: %s <MNEDEFFILE>", argv[0]);
+  if (argc == 1) {
+    err (EXIT_FAILURE, "usage: %s <MNEDEFFILE>", argv[0]);
+    count++;
+  }
 
   //i386_debug = 1;
   infname = argv[1];
@@ -62,11 +65,13 @@
   else
     {
       i386_in = fopen (infname, "r");
-      if (i386_in == NULL)
-	error (EXIT_FAILURE, errno, "cannot open %s", argv[1]);
+      if (i386_in == NULL) {
+	err (EXIT_FAILURE, "cannot open %s", argv[1]);
+        count++;
+      }
     }
 
   i386_parse ();
 
-  return error_message_count != 0;
+  return count != 0;
 }
diff -Nuar elfutils-0.166.orig/libcpu/i386_lex.c elfutils-0.166/libcpu/i386_lex.c
--- elfutils-0.166.orig/libcpu/i386_lex.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libcpu/i386_lex.c	2016-07-09 13:59:54.844923611 +0100
@@ -2012,7 +2012,7 @@
 static void
 invalid_char (int ch)
 {
-  error (0, 0, (isascii (ch)
+  err (0, (isascii (ch)
 		? gettext ("invalid character '%c' at line %d; ignored")
 		: gettext ("invalid character '\\%o' at line %d; ignored")),
 	 ch, i386_lineno);
diff -Nuar elfutils-0.166.orig/libcpu/i386_lex.l elfutils-0.166/libcpu/i386_lex.l
--- elfutils-0.166.orig/libcpu/i386_lex.l	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libcpu/i386_lex.l	2016-07-09 13:59:54.844923611 +0100
@@ -118,7 +118,7 @@
 static void
 invalid_char (int ch)
 {
-  error (0, 0, (isascii (ch)
+  err (0, (isascii (ch)
 		? gettext ("invalid character '%c' at line %d; ignored")
 		: gettext ("invalid character '\\%o' at line %d; ignored")),
 	 ch, yylineno);
diff -Nuar elfutils-0.166.orig/libcpu/i386_parse.c elfutils-0.166/libcpu/i386_parse.c
--- elfutils-0.166.orig/libcpu/i386_parse.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libcpu/i386_parse.c	2016-07-09 14:02:39.676195897 +0100
@@ -1476,9 +1476,6 @@
         case 2:
 #line 248 "/home/mark/src/elfutils/libcpu/i386_parse.y" /* yacc.c:1646  */
     {
-		      if (error_message_count != 0)
-			error (EXIT_FAILURE, 0,
-			       "terminated due to previous error");
 
 		      instrtable_out ();
 		    }
@@ -1510,11 +1507,11 @@
 		      newp->from = (yyvsp[-1].str);
 		      newp->to = (yyvsp[0].str);
 		      if (tfind (newp, &synonyms, compare_syn) != NULL)
-			error (0, 0,
+			err (0,
 			       "%d: duplicate definition for synonym '%s'",
 			       i386_lineno, (yyvsp[-1].str));
 		      else if (tsearch ( newp, &synonyms, compare_syn) == NULL)
-			error (EXIT_FAILURE, 0, "tsearch");
+			err (EXIT_FAILURE, "tsearch");
 		    }
 #line 1520 "i386_parse.c" /* yacc.c:1646  */
     break;
@@ -1525,7 +1522,7 @@
 		      if ((yyvsp[-3].field) != NULL && strcmp ((yyvsp[-3].field)->name, "RE") != 0
 			  && strcmp ((yyvsp[-3].field)->name, "R") != 0)
 			{
-			  error (0, 0, "%d: only 'R' and 'RE' prefix allowed",
+			  err (0, "%d: only 'R' and 'RE' prefix allowed",
 				 i386_lineno - 1);
 			}
 		      if (check_duplicates ((yyvsp[-5].bit)) == 0
@@ -1550,7 +1547,7 @@
 			    {
 			      if (tsearch ((yyvsp[-2].str), &mnemonics,
 					   (comparison_fn_t) strcmp) == NULL)
-				error (EXIT_FAILURE, errno, "tsearch");
+				err (EXIT_FAILURE, "tsearch");
 			      ++nmnemonics;
 			    }
 
@@ -1571,7 +1568,7 @@
 			      else if (strcmp ((yyvsp[-1].field)->name, "D") == 0)
 				newp->suffix = suffix_D;
 			      else
-				error (EXIT_FAILURE, 0,
+				err (EXIT_FAILURE,
 				       "%s: %d: unknown suffix '%s'",
 				       infname, i386_lineno - 1, (yyvsp[-1].field)->name);
 
@@ -1584,7 +1581,7 @@
 				  ns->idx = ++nsuffixes;
 				  if (tsearch (ns, &suffixes, compare_suf)
 				      == NULL)
-				    error (EXIT_FAILURE, errno, "tsearch");
+				    err (EXIT_FAILURE, "tsearch");
 				}
 			    }
 
@@ -1615,7 +1612,7 @@
 		      res = tfind (&search, &bitfields, bitfield_compare);
 		      if (res == NULL)
 			{
-			  error (0, 0, "%d: unknown bitfield '%s'",
+			  err (0, "%d: unknown bitfield '%s'",
 				 i386_lineno, search.name);
 			  (yyval.field) = NULL;
 			}
@@ -1704,7 +1701,7 @@
 		      res = tfind (&search, &bitfields, bitfield_compare);
 		      if (res == NULL)
 			{
-			  error (0, 0, "%d: unknown bitfield '%s'",
+			  err (0, "%d: unknown bitfield '%s'",
 				 i386_lineno, search.name);
 			  (yyval.bit)->type = failure;
 			}
@@ -1797,7 +1794,7 @@
 			    (yyval.name)->field = &bx_reg;
 			  else
 			    {
-			      error (0, 0, "%d: unknown bitfield '%s'",
+			      err (0, "%d: unknown bitfield '%s'",
 				     i386_lineno, search.name);
 			      (yyval.name)->field = NULL;
 			    }
@@ -2080,7 +2077,7 @@
 static void
 yyerror (const char *s)
 {
-  error (0, 0, gettext ("while reading i386 CPU description: %s at line %d"),
+  err (0, gettext ("while reading i386 CPU description: %s at line %d"),
          gettext (s), i386_lineno);
 }
 
@@ -2105,14 +2102,14 @@
 
   if (tfind (newp, &bitfields, bitfield_compare) != NULL)
     {
-      error (0, 0, "%d: duplicated definition of bitfield '%s'",
+      err (0, "%d: duplicated definition of bitfield '%s'",
 	     i386_lineno, name);
       free (name);
       return;
     }
 
   if (tsearch (newp, &bitfields, bitfield_compare) == NULL)
-    error (EXIT_FAILURE, errno, "%d: cannot insert new bitfield '%s'",
+    err (EXIT_FAILURE, "%d: cannot insert new bitfield '%s'",
 	   i386_lineno, name);
 }
 
@@ -2152,7 +2149,7 @@
 	}
       obstack_1grow (&os, '\0');
 
-      error (0, 0, "%d: field '%s' not a multiple of 8 bits in size",
+      err (0, "%d: field '%s' not a multiple of 8 bits in size",
 	     i386_lineno, (char *) obstack_finish (&os));
 
       obstack_free (&os, NULL);
@@ -2173,7 +2170,7 @@
 	{
 	  if (val->field->tmp == testcnt)
 	    {
-	      error (0, 0, "%d: bitfield '%s' used more than once",
+	      err (0, "%d: bitfield '%s' used more than once",
 		     i386_lineno - 1, val->field->name);
 	      result = 1;
 	    }
@@ -2210,7 +2207,7 @@
 
 	    if (runp == NULL)
 	      {
-		error (0, 0, "%d: unknown bitfield '%s' used in output format",
+		err (0, "%d: unknown bitfield '%s' used in output format",
 		       i386_lineno - 1, name->field->name);
 		result = 1;
 	      }
@@ -2254,7 +2251,7 @@
 #if 0
 	  if (runp == NULL)
 	    {
-	      error (0, 0, "%d: bitfield '%s' not used",
+	      err (0, "%d: bitfield '%s' not used",
 		     i386_lineno - 1, bitval->field->name);
 	      result = 1;
 	    }
@@ -2317,7 +2314,7 @@
       if (runp->type == string)
 	{
 	  if (instr->operands[n].str != NULL)
-	    error (EXIT_FAILURE, 0,
+	    err (EXIT_FAILURE,
 		   "%d: cannot have more than one string parameter",
 		   i386_lineno - 1);
 
@@ -2371,7 +2368,7 @@
 	  else if (instr->operands[n].off3 == 0)
 	    instr->operands[n].off3 = bitoff;
 	  else
-	    error (EXIT_FAILURE, 0,
+	    err (EXIT_FAILURE,
 		   "%d: cannot have more than three fields in parameter",
 		   i386_lineno - 1);
 
@@ -2447,7 +2444,7 @@
 		newp->str = runp->operands[i].fct;
 		newp->idx = 0;
 		if (tsearch (newp, &fct_names[i], compare_argstring) == NULL)
-		  error (EXIT_FAILURE, errno, "tsearch");
+		  err (EXIT_FAILURE, "tsearch");
 		++nfct_names[i];
 	      }
 
@@ -2460,7 +2457,7 @@
 		    newp->str = runp->operands[i].str;
 		    newp->idx = 0;
 		    if (tsearch (newp, &strs[i], compare_argstring) == NULL)
-		      error (EXIT_FAILURE, errno, "tsearch");
+		      err (EXIT_FAILURE, "tsearch");
 		    ++nstrs[i];
 		  }
 	      }
diff -Nuar elfutils-0.166.orig/libcpu/i386_parse.y elfutils-0.166/libcpu/i386_parse.y
--- elfutils-0.166.orig/libcpu/i386_parse.y	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libcpu/i386_parse.y	2016-07-09 13:59:54.848923642 +0100
@@ -246,10 +246,6 @@
 
 spec:		  masks kPERCPERC '\n' instrs
 		    {
-		      if (error_message_count != 0)
-			error (EXIT_FAILURE, 0,
-			       "terminated due to previous error");
-
 		      instrtable_out ();
 		    }
 		;
@@ -270,11 +266,11 @@
 		      newp->from = $2;
 		      newp->to = $3;
 		      if (tfind (newp, &synonyms, compare_syn) != NULL)
-			error (0, 0,
+			err (0, 0,
 			       "%d: duplicate definition for synonym '%s'",
 			       i386_lineno, $2);
 		      else if (tsearch ( newp, &synonyms, compare_syn) == NULL)
-			error (EXIT_FAILURE, 0, "tsearch");
+			err (EXIT_FAILURE, "tsearch");
 		    }
 		|
 		;
@@ -288,7 +284,7 @@
 		      if ($3 != NULL && strcmp ($3->name, "RE") != 0
 			  && strcmp ($3->name, "R") != 0)
 			{
-			  error (0, 0, "%d: only 'R' and 'RE' prefix allowed",
+			  err (0, "%d: only 'R' and 'RE' prefix allowed",
 				 i386_lineno - 1);
 			}
 		      if (check_duplicates ($1) == 0
@@ -313,7 +309,7 @@
 			    {
 			      if (tsearch ($4, &mnemonics,
 					   (comparison_fn_t) strcmp) == NULL)
-				error (EXIT_FAILURE, errno, "tsearch");
+				err (EXIT_FAILURE, "tsearch");
 			      ++nmnemonics;
 			    }
 
@@ -334,7 +330,7 @@
 			      else if (strcmp ($5->name, "D") == 0)
 				newp->suffix = suffix_D;
 			      else
-				error (EXIT_FAILURE, 0,
+				err (EXIT_FAILURE,
 				       "%s: %d: unknown suffix '%s'",
 				       infname, i386_lineno - 1, $5->name);
 
@@ -347,7 +343,7 @@
 				  ns->idx = ++nsuffixes;
 				  if (tsearch (ns, &suffixes, compare_suf)
 				      == NULL)
-				    error (EXIT_FAILURE, errno, "tsearch");
+				    err (EXIT_FAILURE, "tsearch");
 				}
 			    }
 
@@ -377,7 +373,7 @@
 		      res = tfind (&search, &bitfields, bitfield_compare);
 		      if (res == NULL)
 			{
-			  error (0, 0, "%d: unknown bitfield '%s'",
+			  err (0, "%d: unknown bitfield '%s'",
 				 i386_lineno, search.name);
 			  $$ = NULL;
 			}
@@ -440,7 +436,7 @@
 		      res = tfind (&search, &bitfields, bitfield_compare);
 		      if (res == NULL)
 			{
-			  error (0, 0, "%d: unknown bitfield '%s'",
+			  err (0, "%d: unknown bitfield '%s'",
 				 i386_lineno, search.name);
 			  $$->type = failure;
 			}
@@ -512,7 +508,7 @@
 			    $$->field = &bx_reg;
 			  else
 			    {
-			      error (0, 0, "%d: unknown bitfield '%s'",
+			      err (0, "%d: unknown bitfield '%s'",
 				     i386_lineno, search.name);
 			      $$->field = NULL;
 			    }
@@ -552,7 +548,7 @@
 static void
 yyerror (const char *s)
 {
-  error (0, 0, gettext ("while reading i386 CPU description: %s at line %d"),
+  err (0, gettext ("while reading i386 CPU description: %s at line %d"),
          gettext (s), i386_lineno);
 }
 
@@ -577,14 +573,14 @@
 
   if (tfind (newp, &bitfields, bitfield_compare) != NULL)
     {
-      error (0, 0, "%d: duplicated definition of bitfield '%s'",
+      err (0, "%d: duplicated definition of bitfield '%s'",
 	     i386_lineno, name);
       free (name);
       return;
     }
 
   if (tsearch (newp, &bitfields, bitfield_compare) == NULL)
-    error (EXIT_FAILURE, errno, "%d: cannot insert new bitfield '%s'",
+    err (EXIT_FAILURE, "%d: cannot insert new bitfield '%s'",
 	   i386_lineno, name);
 }
 
@@ -624,7 +620,7 @@
 	}
       obstack_1grow (&os, '\0');
 
-      error (0, 0, "%d: field '%s' not a multiple of 8 bits in size",
+      err (0, "%d: field '%s' not a multiple of 8 bits in size",
 	     i386_lineno, (char *) obstack_finish (&os));
 
       obstack_free (&os, NULL);
@@ -645,7 +641,7 @@
 	{
 	  if (val->field->tmp == testcnt)
 	    {
-	      error (0, 0, "%d: bitfield '%s' used more than once",
+	      err (0, "%d: bitfield '%s' used more than once",
 		     i386_lineno - 1, val->field->name);
 	      result = 1;
 	    }
@@ -682,7 +678,7 @@
 
 	    if (runp == NULL)
 	      {
-		error (0, 0, "%d: unknown bitfield '%s' used in output format",
+		err (0, "%d: unknown bitfield '%s' used in output format",
 		       i386_lineno - 1, name->field->name);
 		result = 1;
 	      }
@@ -726,7 +722,7 @@
 #if 0
 	  if (runp == NULL)
 	    {
-	      error (0, 0, "%d: bitfield '%s' not used",
+	      err (0, "%d: bitfield '%s' not used",
 		     i386_lineno - 1, bitval->field->name);
 	      result = 1;
 	    }
@@ -789,7 +785,7 @@
       if (runp->type == string)
 	{
 	  if (instr->operands[n].str != NULL)
-	    error (EXIT_FAILURE, 0,
+	    err (EXIT_FAILURE,
 		   "%d: cannot have more than one string parameter",
 		   i386_lineno - 1);
 
@@ -843,7 +839,7 @@
 	  else if (instr->operands[n].off3 == 0)
 	    instr->operands[n].off3 = bitoff;
 	  else
-	    error (EXIT_FAILURE, 0,
+	    err (EXIT_FAILURE,
 		   "%d: cannot have more than three fields in parameter",
 		   i386_lineno - 1);
 
@@ -919,7 +915,7 @@
 		newp->str = runp->operands[i].fct;
 		newp->idx = 0;
 		if (tsearch (newp, &fct_names[i], compare_argstring) == NULL)
-		  error (EXIT_FAILURE, errno, "tsearch");
+		  err (EXIT_FAILURE, "tsearch");
 		++nfct_names[i];
 	      }
 
@@ -932,7 +928,7 @@
 		    newp->str = runp->operands[i].str;
 		    newp->idx = 0;
 		    if (tsearch (newp, &strs[i], compare_argstring) == NULL)
-		      error (EXIT_FAILURE, errno, "tsearch");
+		      err (EXIT_FAILURE, "tsearch");
 		    ++nstrs[i];
 		  }
 	      }
diff -Nuar elfutils-0.166.orig/libdw/libdw_alloc.c elfutils-0.166/libdw/libdw_alloc.c
--- elfutils-0.166.orig/libdw/libdw_alloc.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/libdw/libdw_alloc.c	2016-07-09 13:59:54.848923642 +0100
@@ -75,5 +75,5 @@
 __libdw_oom (void)
 {
   while (1)
-    error (EXIT_FAILURE, ENOMEM, "libdw");
+    err (EXIT_FAILURE, "libdw");
 }
diff -Nuar elfutils-0.166.orig/src/findtextrel.c elfutils-0.166/src/findtextrel.c
--- elfutils-0.166.orig/src/findtextrel.c	2016-03-31 09:59:09.000000000 +0100
+++ elfutils-0.166/src/findtextrel.c	2016-07-09 14:01:15.642547265 +0100
@@ -218,14 +218,14 @@
   int fd = open (real_fname, O_RDONLY);
   if (fd == -1)
     {
-      error (0, errno, gettext ("cannot open '%s'"), fname);
+      err (0, gettext ("cannot open '%s'"), fname);
       return 1;
     }
 
   Elf *elf = elf_begin (fd, ELF_C_READ_MMAP, NULL);
   if (elf == NULL)
     {
-      error (0, 0, gettext ("cannot create ELF descriptor for '%s': %s"),
+      err (0, gettext ("cannot create ELF descriptor for '%s': %s"),
 	     fname, elf_errmsg (-1));
       goto err_close;
     }
@@ -235,7 +235,7 @@
   GElf_Ehdr *ehdr = gelf_getehdr (elf, &ehdr_mem);
   if (ehdr == NULL)
     {
-      error (0, 0, gettext ("cannot get ELF header '%s': %s"),
+      err (0, gettext ("cannot get ELF header '%s': %s"),
 	     fname, elf_errmsg (-1));
     err_elf_close:
       elf_end (elf);
@@ -246,7 +246,7 @@
 
   if (ehdr->e_type != ET_DYN)
     {
-      error (0, 0, gettext ("'%s' is not a DSO or PIE"), fname);
+      err (0, gettext ("'%s' is not a DSO or PIE"), fname);
       goto err_elf_close;
     }
 
@@ -265,7 +265,7 @@
 
       if (shdr == NULL)
 	{
-	  error (0, 0,
+	  err (0,
 		 gettext ("getting get section header of section %zu: %s"),
 		 elf_ndxscn (scn), elf_errmsg (-1));
 	  goto err_elf_close;
@@ -289,7 +289,7 @@
 		  dyn = gelf_getdyn (data, cnt, &dynmem);
 		  if (dyn == NULL)
 		    {
-		      error (0, 0, gettext ("cannot read dynamic section: %s"),
+		      err (0, gettext ("cannot read dynamic section: %s"),
 			     elf_errmsg (-1));
 		      goto err_elf_close;
 		    }
@@ -310,7 +310,7 @@
 
   if (!have_textrel)
     {
-      error (0, 0, gettext ("no text relocations reported in '%s'"), fname);
+      err (0, gettext ("no text relocations reported in '%s'"), fname);
       goto err_elf_close;
     }
 
@@ -322,11 +322,11 @@
   struct segments *segments
     = (struct segments *) malloc (nsegments_max * sizeof (segments[0]));
   if (segments == NULL)
-    error (1, errno, gettext ("while reading ELF file"));
+    err (1, gettext ("while reading ELF file"));
 
   size_t phnum;
   if (elf_getphdrnum (elf, &phnum) != 0)
-    error (1, 0, gettext ("cannot get program header count: %s"),
+    err (1, gettext ("cannot get program header count: %s"),
            elf_errmsg (-1));
 
 
@@ -336,7 +336,7 @@
       GElf_Phdr *phdr = gelf_getphdr (elf, i, &phdr_mem);
       if (phdr == NULL)
 	{
-	  error (0, 0,
+	  err (0,
 		 gettext ("cannot get program header index at offset %zd: %s"),
 		 i, elf_errmsg (-1));
 	  result = 1;
@@ -354,7 +354,7 @@
 					       * sizeof (segments[0]));
 	      if (segments == NULL)
 		{
-		  error (0, 0, gettext ("\
+		  err (0, gettext ("\
 cannot get program header index at offset %zd: %s"),
 			 i, elf_errmsg (-1));
 		  result = 1;
@@ -405,7 +405,7 @@
 
 	  if (shdr == NULL)
 	    {
-	      error (0, 0,
+	      err (0,
 		     gettext ("cannot get section header of section %zu: %s"),
 		     elf_ndxscn (scn), elf_errmsg (-1));
 	      result = 1;
@@ -418,7 +418,7 @@
 	      symscn = elf_getscn (elf, shdr->sh_link);
 	      if (symscn == NULL)
 		{
-		  error (0, 0, gettext ("\
+		  err (0, gettext ("\
 cannot get symbol table section %zu in '%s': %s"),
 			 (size_t) shdr->sh_link, fname, elf_errmsg (-1));
 		  result = 1;
@@ -438,7 +438,7 @@
 		  GElf_Rel *rel = gelf_getrel (data, cnt, &rel_mem);
 		  if (rel == NULL)
 		    {
-		      error (0, 0, gettext ("\
+		      err (0, gettext ("\
 cannot get relocation at index %d in section %zu in '%s': %s"),
 			     cnt, elf_ndxscn (scn), fname, elf_errmsg (-1));
 		      result = 1;
@@ -461,7 +461,7 @@
 		  GElf_Rela *rela = gelf_getrela (data, cnt, &rela_mem);
 		  if (rela == NULL)
 		    {
-		      error (0, 0, gettext ("\
+		      err (0, gettext ("\
 cannot get relocation at index %d in section %zu in '%s': %s"),
 			     cnt, elf_ndxscn (scn), fname, elf_errmsg (-1));
 		      result = 1;
